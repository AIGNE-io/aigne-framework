This document provides a detailed guide to the `AIAgent` class, the core component for creating AI-powered agents in the AIGNE Framework. `AIAgent` leverages large language models (LLMs) to process inputs, execute complex tasks, and generate intelligent responses.

## Overview

The `AIAgent` is a versatile agent that connects to a specified language model to interpret user input and perform actions. It serves as the foundation for building sophisticated AI applications, with built-in support for customizable instructions, tool usage (function calling), and response streaming.

Key features include:
- **Language Model Integration**: Seamlessly connects to any supported chat model (e.g., OpenAI, Gemini, Claude).
- **Customizable Behavior**: Use powerful prompt instructions to define the agent's personality, goals, and constraints.
- **Tool Usage and Function Calling**: Extend the agent's capabilities by providing it with tools (skills) that it can call to perform specific actions, such as interacting with APIs or databases.
- **Flexible Workflow Patterns**: Supports various execution modes, including automatic tool selection, required tool usage, and a specialized "router" mode for directing tasks to other agents.
- **Streaming Support**: Capable of streaming responses as they are generated by the model, enabling real-time applications.
- **Structured Data Extraction**: Can be configured to parse and extract structured data (e.g., JSON, YAML) from the model's streaming output.

## Core Concepts

Understanding these core concepts is key to effectively using `AIAgent`.

### Instructions

The `instructions` property is the primary way to guide the agent's behavior. It can be a simple string or a `PromptBuilder` instance for more complex scenarios. These instructions are typically used to construct the system prompt sent to the language model, setting the context for the entire conversation.

**Example:**
```typescript
const agent = AIAgent.from({
  name: "HaikuBot",
  instructions: "You are a poetic assistant who only responds in haikus.",
});
```

### Input and Output Keys

`AIAgent` uses keys to map data between the input message, the model, and the output message.
- `inputKey`: Specifies which property from the input message should be treated as the primary user text.
- `outputKey`: Defines the property in the output message where the model's final text response will be placed. It defaults to `message`.

**Example:**
```typescript
const agent = AIAgent.from({
  inputKey: "question", // Expects input like { question: "..." }
  outputKey: "answer",  // Produces output like { answer: "..." }
  instructions: "Answer the user's question.",
});
```

### Tool Choice

The `toolChoice` option controls how the agent utilizes its skills (tools). This is a powerful feature for building action-oriented agents.

- `AIAgentToolChoice.auto` (Default): The model decides whether to call a tool based on the user's input.
- `AIAgentToolChoice.none`: The model will not call any tools.
- `AIAgentToolChoice.required`: The model is forced to call one of the available tools.
- `AIAgentToolChoice.router`: A special mode where the agent's sole purpose is to select the single best tool (or other agent) to handle the request and then route the input directly to it.

## Creating an AIAgent

The most straightforward way to create an `AIAgent` is by using the static `AIAgent.from()` method.

### Basic Example

Hereâ€™s a minimal example of an `AIAgent` that uses an OpenAI model to respond to a message.

```typescript
import { AIAgent, AIGNE } from "@aigne/core";
import { OpenAIChatModel } from "@aigne/openai";

// 1. Initialize the model
const model = new OpenAIChatModel({
  apiKey: process.env.OPENAI_API_KEY,
});

// 2. Create the AIAgent instance
const assistantAgent = AIAgent.from({
  name: "Assistant",
  instructions: "You are a helpful and friendly assistant.",
});

// 3. Initialize the AIGNE runtime
const aigne = new AIGNE({ model });

// 4. Invoke the agent
const userAgent = aigne.invoke(assistantAgent);
const result = await userAgent.invoke({ message: "Hello, who are you?" });

console.log(result);
// Output: { message: "I am a helpful and friendly assistant. How can I assist you today?" }
```

### Agent with Tools

To make an agent more powerful, you can provide it with `skills` (tools). In this example, we create a `Calculator` agent and provide it as a skill to a primary `Assistant` agent.

```typescript
import { AIAgent, AIGNE, Skill } from "@aigne/core";
import { OpenAIChatModel } from "@aigne/openai";
import { z } from "zod";

const model = new OpenAIChatModel({
  apiKey: process.env.OPENAI_API_KEY,
  model: "gpt-4o",
});

// 1. Define a skill (tool) for calculations
const calculatorSkill = Skill.from({
  name: "calculator",
  description: "A simple calculator for basic arithmetic operations.",
  input: z.object({
    expression: z.string().describe("The mathematical expression to evaluate, e.g., '2+2'"),
  }),
  func: async ({ expression }) => {
    // In a real-world scenario, use a safe evaluation library
    return { result: eval(expression) };
  },
});

// 2. Create an agent with the skill
const assistantAgent = AIAgent.from({
  name: "Assistant",
  instructions: "You are a helpful assistant. Use the calculator tool for any math questions.",
  skills: [calculatorSkill],
  toolChoice: "auto", // The model will decide when to use the calculator
});

const aigne = new AIGNE({ model });
const userAgent = aigne.invoke(assistantAgent);

// The agent will automatically use the calculator tool
const result = await userAgent.invoke({ message: "What is 127 + 345?" });

console.log(result);
// Output: { message: "127 + 345 is 472." }
```

## AIAgent Workflow

The following diagram illustrates the internal process an `AIAgent` follows when handling a request, including how it interacts with the language model and executes tools.

```d2
direction: down

User: {
  shape: c4-person
}

AIAgent: {
  label: "AIAgent Internal Workflow"
  shape: rectangle
  style: {
    stroke: "#888"
    stroke-width: 2
    stroke-dash: 4
  }

  Input-Message: {
    label: "Input Message\n{ [inputKey]: '...' }"
    shape: rectangle
  }

  Prompt-Builder: {
    label: "Build Prompt\n(Input + Instructions + Skills)"
    shape: rectangle
  }

  Tool-Executor: {
    label: "Execute Tool"
    shape: rectangle
  }

  Skill-Library: {
    label: "Skill Library"
    shape: cylinder
  }

  Response-Formatter: {
    label: "Format Final Response\n(Map to outputKey)"
    shape: rectangle
  }

  Output-Message: {
    label: "Output Message\n{ [outputKey]: '...' }"
    shape: rectangle
  }
}

LLM: {
  label: "LLM (Chat Model)"
  shape: rectangle
}

Tool-Decision: {
  label: "Tool Call Required?"
  shape: diamond
}

User -> AIAgent.Input-Message: "1. Invoke Agent"
AIAgent.Input-Message -> AIAgent.Prompt-Builder
AIAgent.Prompt-Builder -> LLM: "2. Send Request"
LLM -> Tool-Decision: "3. Model Response"
Tool-Decision -> AIAgent.Tool-Executor: "Yes"
AIAgent.Tool-Executor -> AIAgent.Skill-Library: "4. Find & Run Skill"
AIAgent.Skill-Library -> AIAgent.Tool-Executor: "Return Result"
AIAgent.Tool-Executor -> LLM: "5. Send Tool Result"
LLM -> AIAgent.Response-Formatter: "6. Generate Final Response"
Tool-Decision -> AIAgent.Response-Formatter: "No"
AIAgent.Response-Formatter -> AIAgent.Output-Message: "7. Format Output"
AIAgent.Output-Message -> User: "8. Return Result"

```