```d2
direction: down

Invocation: {
  label: "Invocation\n(User Input, History)"
  shape: oval
}

AIAgent: {
  label: "AIAgent Core Logic"
  shape: rectangle
  style: {
    stroke-width: 2
    stroke-dash: 4
  }

  PromptBuilder: {
    label: "1. Build Prompt"
    shape: rectangle
  }

  Response-Handler: {
    label: "3. Handle Response"
    shape: diamond
  }

  Tool-Executor: {
    label: "4a. Execute Tool"
    shape: rectangle
  }

  Output-Processor: {
    label: "4b. Process Final Answer\n(Structured Data Extraction)"
    shape: rectangle
  }
}

Language-Model: {
  label: "Language Model"
  shape: cylinder
}

Tools: {
  label: "Available Tools"
  shape: rectangle
  Tool-A: "Tool A"
  Tool-B: "Tool B"
}

Final-Response: {
  label: "Streamed Response"
  shape: oval
}

Invocation -> AIAgent.PromptBuilder
AIAgent.PromptBuilder -> Language-Model: "2. Send Prompt"
Language-Model -> AIAgent.Response-Handler: "LLM Raw Output"
AIAgent.Response-Handler -> AIAgent.Tool-Executor: "Tool Call"
AIAgent.Tool-Executor -> Tools
Tools -> AIAgent.PromptBuilder: "Return Tool Result to context" {
  style.stroke-dash: 2
}
AIAgent.Response-Handler -> AIAgent.Output-Processor: "Final Answer"
AIAgent.Output-Processor -> Final-Response
```

## Creating an AIAgent

You can create an `AIAgent` instance using the `AIAgent.from()` factory method or by directly using the constructor. At a minimum, an agent requires instructions or an `inputKey` to function.

Here is a basic example of creating a chat agent:

```typescript
import { AIAgent } from "@core/agents/ai-agent";
import { GoogleChatModel } from "@core/models/google";

// Assumes the model is configured elsewhere, e.g., in a central context
const model = new GoogleChatModel({ model: "gemini-1.5-flash" });

const chatAgent = AIAgent.from({
  name: "chat-bot",
  description: "A helpful assistant that can answer questions.",
  instructions: "You are a helpful assistant. Your goal is to assist users in finding the information they need and to engage in friendly conversation.",
  inputKey: "message",
  model: model,
});

async function runChat() {
  const responseStream = await chatAgent.invoke({ message: "Hello, world!" });
  for await (const chunk of responseStream) {
    if (chunk.delta.text?.message) {
      process.stdout.write(chunk.delta.text.message);
    }
  }
}

runChat();
```

This example creates a simple agent that uses the provided instructions to respond to user input passed in the `message` field.

## Configuration Options (`AIAgentOptions`)

The `AIAgentOptions` interface provides extensive configuration possibilities to tailor the agent's behavior.

<x-field-group>
  <x-field data-name="name" data-type="string" data-required="true" data-desc="A unique name for the agent."></x-field>
  <x-field data-name="description" data-type="string" data-required="true" data-desc="A description of the agent's purpose and capabilities."></x-field>
  <x-field data-name="model" data-type="ChatModel" data-required="false" data-desc="The language model instance the agent will use. This can also be provided at invocation time."></x-field>
  <x-field data-name="instructions" data-type="string | PromptBuilder" data-required="false" data-desc="Instructions to guide the AI model's behavior. Can be a simple string or a `PromptBuilder` instance for complex templates."></x-field>
  <x-field data-name="inputKey" data-type="string" data-required="false" data-desc="Specifies which key from the input message should be treated as the primary user message."></x-field>
  <x-field data-name="outputKey" data-type="string" data-default="message" data-desc="Custom key to use for the text output in the response object. Defaults to `message`."></x-field>
  <x-field data-name="toolChoice" data-type="AIAgentToolChoice | Agent" data-default="auto" data-desc="Controls how the agent uses tools. See the 'Tool Usage' section for details."></x-field>
  <x-field data-name="keepTextInToolUses" data-type="boolean" data-required="false" data-desc="If true, text generated by the model alongside a tool call is preserved in the final output."></x-field>
  <x-field data-name="catchToolsError" data-type="boolean" data-default="true" data-desc="If false, the agent will throw an error if a tool execution fails. Defaults to true, allowing the agent to handle the error."></x-field>
  <x-field data-name="structuredStreamMode" data-type="boolean" data-default="false" data-desc="Enables a mode to extract structured metadata (e.g., JSON) from the model's streaming response."></x-field>
  <x-field data-name="customStructuredStreamInstructions" data-type="object" data-required="false" data-desc="Allows full customization of the structured stream behavior, including prompt instructions and metadata parsing logic."></x-field>
  <x-field data-name="memoryAgentsAsTools" data-type="boolean" data-default="false" data-desc="When true, memory agents are made available as tools that the model can call to explicitly retrieve or store information."></x-field>
</x-field-group>

## Tool Usage

A key feature of `AIAgent` is its ability to use other agents as tools. This allows you to build complex systems where an AI agent can delegate tasks to specialized agents for performing actions. The `toolChoice` option controls this behavior.

### `AIAgentToolChoice` Enum

-   **`auto` (Default)**: The language model decides whether to call a tool based on the context of the conversation. This is the most flexible option.
-   **`none`**: Disables all tool usage for the agent, forcing it to rely solely on its own knowledge.
-   **`required`**: Forces the agent to use one of the available tools. The model must make a tool call.
-   **`router`**: A specialized mode where the agent's single purpose is to choose the most appropriate tool and route the user's input directly to it. The `AIAgent` itself does not respond; the chosen tool's output becomes the final response.

### Example: Using a Tool

```typescript
import { Agent } from "@core/agents/agent";
import { AIAgent, AIAgentToolChoice } from "@core/agents/ai-agent";

// A simple tool (an Agent) that gets weather information
const weatherTool = new Agent({
  name: "get_weather",
  description: "Get the current weather for a specific location.",
  inputSchema: {
    type: "object",
    properties: {
      location: { type: "string", description: "The city and state, e.g., San Francisco, CA" },
    },
    required: ["location"],
  },
  async *process(input) {
    yield {
      delta: {
        json: {
          weather: `The weather in ${input.location} is sunny.`,
        },
      },
    };
  },
});

// An AIAgent configured to use the tool
const weatherAssistant = AIAgent.from({
  name: "weather-assistant",
  description: "An assistant that can provide weather forecasts.",
  instructions: "You are a weather assistant. Use the available tools to answer questions about the weather.",
  tools: [weatherTool],
  toolChoice: AIAgentToolChoice.auto,
});

async function getWeather() {
  const responseStream = await weatherAssistant.invoke({
    message: "What's the weather like in New York?",
  });

  for await (const chunk of responseStream) {
    // The final output will be a synthesis of the tool's result
    console.log(chunk);
  }
}

getWeather();
```

## Structured Data Extraction

The `structuredStreamMode` is a powerful feature for scenarios where you need to extract structured information (like JSON) from a language model's response, in addition to plain text. When enabled, the agent looks for special metadata tags in the model's output and parses the content within them.

### Enabling Structured Stream Mode

To use this feature, you must:
1.  Set `structuredStreamMode: true` in the agent's options.
2.  Instruct the model (via the `instructions` prompt) to format its structured output within specific tags (default is `<metadata>...</metadata>`).

### Example: Extracting JSON

```typescript
import { AIAgent } from "@core/agents/ai-agent";

const sentimentAnalyzer = AIAgent.from({
  name: "sentiment-analyzer",
  description: "Analyzes the sentiment of a message and provides a rating.",
  instructions: `
    Analyze the sentiment of the user's message.
    Respond with a brief explanation, and then provide a structured sentiment analysis in a <metadata> tag.
    The metadata should be a YAML object with 'sentiment' (positive, negative, or neutral) and 'score' (0-1) fields.
  `,
  structuredStreamMode: true,
});

async function analyzeSentiment() {
  const responseStream = await sentimentAnalyzer.invoke({
    message: "I am absolutely thrilled with the new update! It's fantastic.",
  });

  for await (const chunk of responseStream) {
    if (chunk.delta.text?.message) {
      // Stream the text part of the response
      process.stdout.write(chunk.delta.text.message);
    }
    if (chunk.delta.json) {
      // The parsed JSON object will appear here
      console.log("\n[METADATA]:", chunk.delta.json);
    }
  }
}

// Expected output would stream the text explanation,
// followed by the parsed JSON object:
// [METADATA]: { sentiment: 'positive', score: 0.95 }

analyzeSentiment();
```

You can further customize the metadata tags and parsing logic using the `customStructuredStreamInstructions` option for formats other than YAML, such as JSON.